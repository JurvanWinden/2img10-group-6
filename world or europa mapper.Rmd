---
title: "R Notebook"
output: html_notebook
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code. 

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Ctrl+Shift+Enter*. 

Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Ctrl+Alt+I*.

When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Ctrl+Shift+K* to preview the HTML file).

The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike *Knit*, *Preview* does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed.

```{r}
# First set your working directory
# get needed packages and import data
source("bootstrap.R")
```



Get a general view of the data by plotting it over the world map

```{r}
# plot world map with dot sizes based on cases
# world_map <- map_data("world")

# ggplot(corona_world) +
#   geom_point(aes(x= Longitude , y = Latitude, colour="red")) +
#   geom_map(dat=world_map, map = world_map,
#            aes(map_id=region), fill="white", color="black") +
#   expand_limits(x = world_map$long, y = world_map$lat)
```



Preprocces the world data
```{r}
# delete all rows where an NA occurs
infection_corona_world <- na.omit(corona_world)

#only take data of Europe
infection_corona_world_Europe1 <- infection_corona_world %>% filter(continentExp == 'Europe')

#Get the number of deaths over complete time by country
sumDeaths <- aggregate(infection_corona_world_Europe1$cases, by=list(Category=infection_corona_world_Europe1$countriesAndTerritories), FUN=sum)
colnames(sumDeaths) <- c("countriesAndTerritories", "sumDeaths")

infection_corona_world_Europe1 <- merge(infection_corona_world_Europe1, sumDeaths,by="countriesAndTerritories")
#Filter on a day
infection_corona_world_Europe <- infection_corona_world_Europe1 %>% filter(day == '20', month == '4',)
```


Define a distance value
```{r}
# determine the manhattan distance (Absolute distance between the two vectors) on the Europe data
infection_corona_world_dist = dist(infection_corona_world_Europe[,12:13], method = "manhattan")
```


Define a filter metric
```{r}
# determine the ratio
infection_corona_world_Europe$ratio <- infection_corona_world_Europe$sumDeaths / infection_corona_world_Europe$popData2018
```


Define the mapper
```{r}
# mapper based on manhattan distande and filter on KDE
infection_corona_world_mapper <- mapper(dist_object = infection_corona_world_dist,
                                filter_values = infection_corona_world_Europe$ratio,
                                num_intervals = 15,
                                percent_overlap = 95,
                                num_bins_when_clustering = 5)

# show the mapper
# infection_corona_world_graph <- graph.adjacency(infection_corona_world_mapper$adjacency, mode="undirected")
# plot(infection_corona_world_graph, layout = layout.auto(infection_corona_world_graph) )

```



Determine values for vertex color and size
```{r}
# determine the mean values of the number of infections
value.mean.vertex <- rep(0,infection_corona_world_mapper$num_vertices)
for (i in 1:infection_corona_world_mapper$num_vertices){
  points.in.vertex <- infection_corona_world_mapper$points_in_vertex[[i]]
  value.mean.vertex[i] <-mean((infection_corona_world_Europe$deaths[points.in.vertex]))
}
# value.mean.vertex

#set vertex size based on how many cities are represented by this vertex
vertex.size <- rep(0,infection_corona_world_mapper$num_vertices)
for (i in 1:infection_corona_world_mapper$num_vertices){
  points.in.vertex <- infection_corona_world_mapper$points_in_vertex[[i]]
  vertex.size[i] <- length((infection_corona_world_mapper$points_in_vertex[[i]]))
}
#vertex.size
```

Plot the mapper
```{r}
# Mapper graph with the vertices colored in function of latitude data and vertex size proportional to the number of points inside
value.mean.vertex.grey <- grey(1-(value.mean.vertex - min(value.mean.vertex))/(max(value.mean.vertex) - min(value.mean.vertex) ))
V(infection_corona_world_graph)$color <- value.mean.vertex.grey
V(infection_corona_world_graph)$size <- vertex.size
plot(infection_corona_world_graph,main ="Mapper Graph")
legend(x=-2, y=-1, c("mean number small","mean number medium","mean number large"),pch=21,
       col="#777777", pt.bg=grey(c(1,0.5,0)), pt.cex=2, cex=.8, bty="n", ncol=1)

```


Plot a mapper with nicer looks

```{r}
library(networkD3)
MapperNodes <- mapperVertices(infection_corona_world_mapper, 1:1000 )
MapperLinks <- mapperEdges(infection_corona_world_mapper)

# create legend with the corresponding country names in stead of row numbers
countries <- MapperNodes$Nodename


for (i in (1: nrow(MapperNodes))){
  temp <- paste("V",i, ":", sep= "")
  split <- strsplit(MapperNodes$Nodename[i], " ")
  for (j in (2 : (length(split[[1]])) ) ) {
    toadd <-  infection_corona_world_Europe$countriesAndTerritories[as.integer(gsub(",","",split[[1]][j]))]
    temp <- paste(temp, toadd)
  }
  countries[i] <- temp
}

# Update nodes, such that the labels are the countries, in stead of row numbers
MapperNodes$Nodename <- countries
MapperNodes

for (i in (1: nrow(MapperNodes))){
  MapperNodes$Nodegroup[i] <- i
}


forceNetwork(Nodes = MapperNodes, Links = MapperLinks, 
             Source = "Linksource", Target = "Linktarget",
             Value = "Linkvalue", NodeID = "Nodegroup",
             Group = "Nodename", opacity = 1, opacityNoHover = 1,
             linkDistance = 25, charge = -10,
             Nodesize = "Nodesize", legend = T,
             fontSize = 25)
```





















