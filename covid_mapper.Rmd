---
title: "Covid Mapper Notebook"
output: html_notebook
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code. 

Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Ctrl+Alt+I*.

When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Ctrl+Shift+K* to preview the HTML file).

The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike *Knit*, *Preview* does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed.

Population density 2015 data source:

https://www.volksgezondheidenzorg.info/onderwerp/bevolking/regionaal-internationaal/bevolkingsomvang

```{r}
# Package installs
# ("TDAmapper")
# install.packages("ggplot2")
# install.packages("devtools")
# devtools::install_github("paultpearson/TDAmapper")
# devtools::install_github("christophergandrud/networkD3")
# install.packages("factoextra")
# install.packages("cluster")
# install.packages("magrittr")
# install.packages("fpc")
# install.packages("dbscan")
```

```{r}
# Import packages
library(devtools)
library(TDAmapper)
library(ggplot2)
library(igraph)
library(networkD3)
library("cluster")
library("factoextra")
library("magrittr")
library("fpc")
library("dbscan")
```

Get coordinate, infection data from NL municipalities. We read the infections as a list of dataframes, the coordinates are a separate dataframe.

```{r}
# Check working directory and read csv
wd = getwd()

coords_directory <- ("./data/COVIDNL_COORDS.csv")
popdensity_directory <- ("./data/bevdh2015.csv")

coords = read.csv(coords_directory, header = TRUE, sep=",", stringsAsFactors = FALSE)
popdensity = read.csv(popdensity_directory, header = TRUE, sep=";", stringsAsFactors = FALSE, colClasses=c("Inwoners.2015"="character","Inwoners.per.km2"="character"))

# Drop useless columns
popdensity = subset(popdensity, select = -c(ID, Indicator))
coords = subset(coords, select = -c(X))

# Remove the . values in the file as they screw up numerical values
popdensity$Inwoners.2015 <- as.numeric(sub('\\.', '', popdensity$Inwoners.2015))
popdensity$Inwoners.per.km2 <- as.numeric(sub('\\.', '', popdensity$Inwoners.per.km2))


# Set wd to data folder so we can read all the csv's as a list
tempwd = paste(wd, "data", "COVIDNL", sep="/")
tempwd

setwd(tempwd)

# Read csv's as list
temp = list.files(pattern="*.csv")
temp
infections = lapply(temp, read.delim, header = TRUE, sep = ";", stringsAsFactors = FALSE)

# Set wd back
setwd(wd)

# Show read data, the coordinates contain some column 'x' but we just ignore this...
coords
popdensity
infections
length(infections)

```

Do some merging so that we have both the coordinate and infection data in each dataframe.

```{r}
# Merge data on municipality
merged = list();
coords_popdensity <- merge(x=coords, y=popdensity, by.x=c('Municipality'), by.y=c('Gemeente'), sort = TRUE)


# Not the most efficient but it does the job,
# we see that not all files have the same format so we check for the 2 most common ones
i = 1
for (inf in infections) {
  d = substr(temp[[i]], 6,9)
  print(d)
  inf$Date <- d
  inf[is.na(inf)] <- 0
  if("Gemeente" %in% colnames(inf)) {
    
    new = merge(x=coords_popdensity, y=inf, by.x=c('Municipality'), by.y=c('Gemeente'), sort = TRUE)
    merged <- c(merged, list(new))
    
  } else if("Category" %in% colnames(inf)) {
    
    new = merge(x=coords_popdensity, y=inf, by.x=c('Municipality'), by.y=c('Category'), sort = TRUE)
    merged <- c(merged, list(new))
    
  } # Disregard others
  i = i + 1
}
merged
bothbeams.data[is.na(bothbeams.data)] <- 0
# Show a merged dataframe
print(merged[[44]])

```


Compute interesting features from the data.

```{r}
# TODO


```

Implement a basic mapper from TDAmapper library.
See also the tutorial from: http://bertrand.michel.perso.math.cnrs.fr/Enseignements/TDA/Mapper.html

```{r}

# Creates a mapper object using the TDAmapper library
create_tda_mapper <- function(filter_values, x_coord, y_coord, intervals=25, num_bins=10, overlap=30) {
    
    basic.coords = data.frame(x_coord, y_coord)
    # Compute distance matrix
    basic.dist = dist(basic.coords)
    length(filter_values)
    if(length(filter_values) == 2) {
      twodim_intervals = c(intervals, intervals)
      return (
        mapper2D(
          dist_object = basic.dist,
          filter_values = filter_values, # Expects a list of two vectors
          num_intervals = twodim_intervals,
          percent_overlap = overlap,
          num_bins_when_clustering = num_bins
        )
      )
    }
    
    return (
      mapper(
          dist_object = basic.dist,
          filter_values = filter_values, 
          num_intervals = intervals,
          percent_overlap = overlap,
          num_bins_when_clustering = num_bins
      )
    )
}

# Creates a basic plot of the given mapper object (TDAmapper class)
# Should also work if you give a custom object with adjacency matrix of nodes (Not tested)
plot_mapper <- function (mapper) {
    # Plot graph 
    graph <- graph.adjacency(mapper$adjacency, mode="undirected")
    plot(graph, layout = layout.auto(graph) )
    return(graph)
}

# Grab some data
first = merged[[3]] # 03/03
second = merged[[32]] # 20/03
third = merged[[1]] # 01/04
first
second
third
firstMapper = create_tda_mapper(first$Aantal, first$Latitude, first$Longitude)
plot_mapper(firstMapper)

secondMapper = create_tda_mapper(second$Aantal, second$Latitude, second$Longitude)
plot_mapper(secondMapper)

thirdMapper = create_tda_mapper(third$Aantal, third$Latitude, third$Longitude)
plot_mapper(thirdMapper)

```
A more advanced example using the networkD3 library which yields way nicer visualizations

```{r}
# To be sure that we have this imported
# library(networkD3)

# Create a mapper object
mapper = create_tda_mapper(third$Aantal, third$Latitude, third$Longitude, 20, 10, 30)


plotForceNetwork <- function(mapper, labels) {
  MapperNodes <- mapperVertices(mapper, labels)
  MapperLinks <- mapperEdges(mapper)
  
  forceNetwork(
    Nodes = MapperNodes, Links = MapperLinks, 
    Source = "Linksource", Target = "Linktarget",
    Value = "Linkvalue", NodeID = "Nodename",
    Group = "Nodegroup", opacity = 1, opacityNoHover = 1,
    linkDistance = 25, charge = -10,
    Nodesize = "Nodesize", legend = T
  ) 
}

plotForceNetwork(mapper, first$Aantal)

```

Other mapper solutions:

More advanced force network which computes some other statistics on the nodes

```{r}
mapper = create_tda_mapper(second$Aantal, second$Longitude, second$Latitude, 20, 10, 30)

MapperNodes <- mapperVertices(mapper, second$Aantal )
MapperLinks <- mapperEdges(mapper)


municipalities <- MapperNodes$Nodename
sums <- c()
# Map countries to label names
for (i in (1: nrow(MapperNodes))){
  sum = 0
  temp <- paste("V",i, ":", sep= "")
  split <- strsplit(MapperNodes$Nodename[i], " ")

  for (j in (2 : (length(split[[1]])) ) ) {
    num_other = as.integer(gsub(",","",split[[1]][[j]]))
    index = match(num_other, second$Aantal)
    prov <-  second$Municipality[[index]]
    sum <- sum + num_other
    temp <- paste(temp, prov)
  }
  sums[i] <- sum
  municipalities[i] <- paste(temp, sep = ", ")
}

for (i in (1: nrow(MapperNodes))){
  MapperNodes$Nodegroup[i] <- i
}


MapperNodes$Nodesize <- sums*0.02
MapperNodes$Nodename <- municipalities
MapperNodes$NodeCases <- sums

municipalities

MapperNodes

forceNetwork(Nodes = MapperNodes, Links = MapperLinks, 
            Source = "Linksource", Target = "Linktarget",
            Value = "Linkvalue", NodeID = "Nodegroup",
            Group = "Nodename", opacity = 1, opacityNoHover = 1,
            linkDistance = 75, charge = -10,
            Nodesize = "Nodesize")  
```

Trying out custom clustering + filter values:
Also see: https://www.datanovia.com/en/blog/types-of-clustering-methods-overview-and-quick-start-r-code/

```{r}
first.subset <- subset(first, select = c(Latitude, Longitude))
second.subset <- subset(second, select = c(Aantal, Inwoners.per.km2))
third.subset <- subset(third, select = c(Aantal, Aantal.per.100.000.inwoners))

# I assume here that the ordering is correct
row.names(first.subset) <- first$Municipality
row.names(second.subset) <- second$Municipality
row.names(third.subset) <- third$Municipality

print(first.subset)
print(second.subset)
print(third.subset)

# Computes the 'optimal' number of kmeans clusters for our data
fviz_nbclust(first.subset, kmeans, method = "gap_stat")
fviz_nbclust(second.subset, kmeans, method = "gap_stat")
fviz_nbclust(third.subset, kmeans, method = "gap_stat")

# Create clusters
kmeans.first <- kmeans(first.subset, 8, nstart = 20)
kmeans.second <- kmeans(second.subset, 8, nstart = 30)
kmeans.third <- kmeans(third.subset, 10, nstart = 30)

# Visualize
fviz_cluster(kmeans.first, data = first.subset,
             ellipse.type = "convex",
             palette = "jco",
             ggtheme = theme_minimal())

fviz_cluster(kmeans.second, data = second.subset,
             ellipse.type = "convex",
             palette = "jco",
             ggtheme = theme_minimal())

fviz_cluster(kmeans.third, data = third.subset,
             ellipse.type = "convex",
             palette = "jco",
             ggtheme = theme_minimal())

```


Define a custom filter function

```{r}
# print(kmeans.first)
prov_first = setNames(aggregate(first$Aantal, by=list(Province=first$Province), FUN=sum), c('Province', 'Aantal'))
prov_lat = setNames(aggregate(first$Latitude, by=list(Province=first$Province), FUN=mean), c('Province', 'Latitude'))
prov_long = setNames(aggregate(first$Longitude, by=list(Province=first$Province), FUN=mean), c('Province', 'Longitude'))
prov_first = merge(prov_first, prov_lat, by.x="Province", by.y="Province")
prov_first = merge(prov_first, prov_long, by.x="Province", by.y="Province")
prov_first

prov_second = setNames(aggregate(second$Aantal, by=list(Province=second$Province), FUN=sum), c('Province', 'Aantal'))
prov_lat = setNames(aggregate(second$Latitude, by=list(Province=second$Province), FUN=mean), c('Province', 'Latitude'))
prov_long = setNames(aggregate(second$Longitude, by=list(Province=second$Province), FUN=mean), c('Province', 'Longitude'))
prov_second = merge(prov_second, prov_lat, by.x="Province", by.y="Province")
prov_second = merge(prov_second, prov_long, by.x="Province", by.y="Province")
prov_second



prov_third = setNames(aggregate(third$Aantal, by=list(Province=third$Province), FUN=sum), c('Province', 'Aantal'))
prov_lat = setNames(aggregate(third$Latitude, by=list(Province=third$Province), FUN=mean), c('Province', 'Latitude'))
prov_long = setNames(aggregate(third$Longitude, by=list(Province=third$Province), FUN=mean), c('Province', 'Longitude'))
prov_third = merge(prov_third, prov_lat, by.x="Province", by.y="Province")
prov_third = merge(prov_third, prov_long, by.x="Province", by.y="Province")
prov_third

mapper = create_tda_mapper(prov_first$Aantal, prov_first$Longitude, prov_first$Latitude, 20, 10, 30)
MapperNodes <- mapperVertices(mapper, prov_first$Aantal)
MapperLinks <- mapperEdges(mapper)
province <- MapperNodes$Nodename
sums <- 0

# Map countries to label names
for (i in (1: nrow(MapperNodes))){
  print(i)
  sum = 0
  temp <- paste("V",i, ":", sep= "")
  split <- strsplit(MapperNodes$Nodename[i], " ")

  for (j in (2 : (length(split[[1]])) ) ) {
    num_other = as.integer(gsub(",","",split[[1]][[j]]))
    index = match(num_other, prov_first$Aantal)
    print(index)
    prov <-  prov_first$Province[[index]]
    sum <- sum + num_other
    temp <- paste(temp, prov)
  }
  
  province[i] <- paste(temp, sep = ", ")
  sums[i] <- sum
  print(province[i])

}


MapperNodes$Nodesize <- sums *0.02

for (i in (1: nrow(MapperNodes))){
  MapperNodes$Nodegroup[i] <- i
}

means
MapperNodes$Nodename <- province
MapperNodes$NodeCases <- sums

MapperNodes

forceNetwork(Nodes = MapperNodes, Links = MapperLinks, 
            Source = "Linksource", Target = "Linktarget",
            Value = "Linkvalue", NodeID = "Nodegroup",
            Group = "Nodename", opacity = 1, opacityNoHover = 1,
            linkDistance = 50, charge = -10,
            Nodesize = "Nodesize")  

```


GERMANY


```{r}
source("bootstrap.R")
wd = getwd()
wd
germanyLatLong <- read_csv("./data/duitsland-latlong.csv") 
germany <- read_csv("./data/duitsland.csv") %>%
  rename(
    dateRep = `time_iso8601`,
    `Schleswig-Holstein` = de_sh  ,
    `Hamburg` = de_hh  ,
    `Niedersachsen` = de_ni  ,
    `Bremen` = de_hb  ,
    `Nordrhein-Westfalen`  = de_nw  ,
    `Hessen` = de_he  ,
    `Rheinland-Pfalz` =de_rp  ,
    `Baden-Wurttemberg` = de_bw  ,
    `Bayern` = de_by  ,
    `Saarland` = de_sl  ,
    `Brandenburg`= de_bb  ,
    `Mecklenburg-Vorpommern` = de_mv  ,
    `Sachsen` =de_sn  ,
    `Sachsen-Anhalt` = de_st  ,
    `Thuringen` = de_th  ,
    `Berlin` = de_be  ,
    SumCases = sum_cases
    ) %>%
  pivot_longer(-c(dateRep, SumCases ), names_to = "Provinces", values_to = "Cases") %>%
  select(-c("SumCases")) %>%
  left_join(germanyLatLong) 
germany_long <- germany
germany <- germany %>%
  pivot_wider(names_from = dateRep, values_from = Cases )

rm(germanyLatLong)
germany
```


```{r}
inf = germany$`2020-03-20 17:00:00`
mapper = create_tda_mapper(inf, germany$Longitude, germany$Latitude, 20, 10, 30)
MapperNodes <- mapperVertices(mapper, inf)
MapperLinks <- mapperEdges(mapper)
province <- MapperNodes$Nodename
sums <- c()
# Map countries to label names
for (i in (1: nrow(MapperNodes))){
  sum = 0
  print(i)
  temp <- paste("V",i, ":", sep= "")
  split <- strsplit(MapperNodes$Nodename[i], " ")

  for (j in (2 : (length(split[[1]])) ) ) {
    num_other = as.integer(gsub(",","",split[[1]][[j]]))
    index = match(num_other, inf)
    prov <-  germany$Provinces[[index]]
    temp <- paste(temp, prov)
    sum <- sum + num_other
  }
  
  province[i] <- paste(temp, sep = ", ")
  print(province[i])
  sums[i] <- sum

}



MapperNodes$Nodesize <- sums * 0.01

for (i in (1: nrow(MapperNodes))){
  MapperNodes$Nodegroup[i] <- i
}

MapperNodes$Nodename <- province
MapperNodes$NodeCases <- sums
MapperNodes


forceNetwork(Nodes = MapperNodes, Links = MapperLinks, 
            Source = "Linksource", Target = "Linktarget",
            Value = "Linkvalue", NodeID = "Nodegroup",
            Group = "Nodename", opacity = 1, opacityNoHover = 1,
            linkDistance = 75, charge = -10,
            Nodesize = "Nodesize")  

```


BELGIUM

```{r}

zipp <- read_csv("./data/zipcode-belgium.csv", col_names = c("zip","City" ,"Longitude", "Latitude" ))
df <- read_csv("data/COVID19BE_CASES_MUNI.csv") %>%
  select(DATE, `TX_DESCR_NL`, `TX_PROV_DESCR_NL`, `TX_ADM_DSTR_DESCR_NL`,`TX_RGN_DESCR_NL`, `CASES`)  %>%
  rename( dateRep = DATE, 
          Province  =TX_PROV_DESCR_NL , 
          City = TX_DESCR_NL, 
          Taal = TX_RGN_DESCR_NL, 
          Cases = CASES,
          Municipality = TX_ADM_DSTR_DESCR_NL ) %>%
  left_join( zipp)

problems(df)
# wrangling
df$Cases[which(df$Cases == "<5")] = 0
df$Cases <- parse_integer(df$Cases)

# Replace NA's with most recent values
df$Cases <- as.integer(na.locf(df$Cases) )

belgie_long <- df
# set to match the world data set or NL Data Set
df <- df %>%
  pivot_wider(names_from = dateRep, values_from = Cases) #%>%
df <- na.locf(df)


belgie <- df
rm(df,zipp)
belgie
```




```{r}

# print(kmeans.first)
prov_first = setNames(aggregate(belgie$`2020-03-04`, by=list(Province=belgie$Province), FUN=sum), c('Province', 'Aantal'))
prov_lat = setNames(aggregate(belgie$Latitude, by=list(Province=belgie$Province), FUN=mean), c('Province', 'Latitude'))
prov_long = setNames(aggregate(belgie$Longitude, by=list(Province=belgie$Province), FUN=mean), c('Province', 'Longitude'))
prov_first = merge(prov_first, prov_lat, by.x="Province", by.y="Province")
prov_first = merge(prov_first, prov_long, by.x="Province", by.y="Province")
prov_first

prov_second = setNames(aggregate(belgie$`2020-03-20`, by=list(Province=belgie$Province), FUN=sum), c('Province', 'Aantal'))
prov_lat = setNames(aggregate(belgie$Latitude, by=list(Province=belgie$Province), FUN=mean), c('Province', 'Latitude'))
prov_long = setNames(aggregate(belgie$Longitude, by=list(Province=belgie$Province), FUN=mean), c('Province', 'Longitude'))
prov_second = merge(prov_second, prov_lat, by.x="Province", by.y="Province")
prov_second = merge(prov_second, prov_long, by.x="Province", by.y="Province")
prov_second

prov_third = setNames(aggregate(belgie$`2020-04-02`, by=list(Province=belgie$Province), FUN=sum), c('Province', 'Aantal'))
prov_lat = setNames(aggregate(belgie$Latitude, by=list(Province=belgie$Province), FUN=mean), c('Province', 'Latitude'))
prov_long = setNames(aggregate(belgie$Longitude, by=list(Province=belgie$Province), FUN=mean), c('Province', 'Longitude'))
prov_third = merge(prov_third, prov_lat, by.x="Province", by.y="Province")
prov_third = merge(prov_third, prov_long, by.x="Province", by.y="Province")
prov_third

mapper = create_tda_mapper(prov_first$Aantal, prov_first$Longitude, prov_first$Latitude, 20, 10, 30)

MapperNodes <- mapperVertices(mapper, prov_first$Aantal)
MapperLinks <- mapperEdges(mapper)
MapperNodes
province <- MapperNodes$Nodename
sums <- 0
# Map countries to label names
for (i in (1: nrow(MapperNodes))){
  print(i)
  sum = 0
  temp <- paste("V",i, ":", sep= "")
  split <- strsplit(MapperNodes$Nodename[i], " ")

  for (j in (2 : (length(split[[1]])) ) ) {
    num_other = as.integer(gsub(",","",split[[1]][[j]]))
    index = match(num_other, prov_first$Aantal)
    prov <-  prov_first$Province[[index]]
    temp <- paste(temp, prov)
    sum <- sum + num_other
  }
  
  province[i] <- paste(temp, sep = ", ")
  print(province[i])
  sums[i] <- sum
}

for (i in (1: nrow(MapperNodes))){
  MapperNodes$Nodegroup[i] <- i
}


MapperNodes$Nodesize <- sums * 0.02
MapperNodes$NodeCases <- sums
MapperNodes$Nodename <- province
MapperNodes


forceNetwork(Nodes = MapperNodes, Links = MapperLinks, 
            Source = "Linksource", Target = "Linktarget",
            Value = "Linkvalue", NodeID = "Nodegroup",
            Group = "Nodename", opacity = 1, opacityNoHover = 1,
            linkDistance = 75, charge = -10,
            Nodesize = "Nodesize")  



```

```{r}

# print(kmeans.first)
prov_first = setNames(aggregate(belgie$`2020-03-04`, by=list(Municipality=belgie$Municipality), FUN=sum), c('Municipality', 'Aantal'))
prov_lat = setNames(aggregate(belgie$Latitude, by=list(Municipality=belgie$Municipality), FUN=mean), c('Municipality', 'Latitude'))
prov_long = setNames(aggregate(belgie$Longitude, by=list(Municipality=belgie$Municipality), FUN=mean), c('Municipality', 'Longitude'))
prov_first = merge(prov_first, prov_lat, by.x="Municipality", by.y="Municipality")
prov_first = merge(prov_first, prov_long, by.x="Municipality", by.y="Municipality")
prov_first

prov_second = setNames(aggregate(belgie$`2020-03-20`, by=list(Municipality=belgie$Municipality), FUN=sum), c('Municipality', 'Aantal'))
prov_lat = setNames(aggregate(belgie$Latitude, by=list(Municipality=belgie$Municipality), FUN=mean), c('Municipality', 'Latitude'))
prov_long = setNames(aggregate(belgie$Longitude, by=list(Municipality=belgie$Municipality), FUN=mean), c('Municipality', 'Longitude'))
prov_second = merge(prov_second, prov_lat, by.x="Municipality", by.y="Municipality")
prov_second = merge(prov_second, prov_long, by.x="Municipality", by.y="Municipality")
prov_second

prov_third = setNames(aggregate(belgie$`2020-04-01`, by=list(Municipality=belgie$Municipality), FUN=sum), c('Municipality', 'Aantal'))
prov_lat = setNames(aggregate(belgie$Latitude, by=list(Municipality=belgie$Municipality), FUN=mean), c('Municipality', 'Latitude'))
prov_long = setNames(aggregate(belgie$Longitude, by=list(Municipality=belgie$Municipality), FUN=mean), c('Municipality', 'Longitude'))
prov_third = merge(prov_third, prov_lat, by.x="Municipality", by.y="Municipality")
prov_third = merge(prov_third, prov_long, by.x="Municipality", by.y="Municipality")
prov_third


mapper = create_tda_mapper(prov_first$Aantal, prov_first$Longitude, prov_first$Latitude, 20, 10, 30)

MapperNodes <- mapperVertices(mapper, prov_first$Aantal)
MapperLinks <- mapperEdges(mapper)

# Compute mean
vertex.mean = c()
mapper$points_in_level_set
for (i in 1:length(mapper$points_in_vertex)){
  vertex.mean <- c(vertex.mean, mean(mapper$points_in_vertex[[i]]))
}

municipalities <- MapperNodes$Nodename


# Map countries to label names
for (i in (1: nrow(MapperNodes))){
  print(i)
  temp <- paste("V",i, ":", sep= "")
  split <- strsplit(MapperNodes$Nodename[i], " ")

  for (j in (2 : (length(split[[1]])) ) ) {
    num_other = as.integer(gsub(",","",split[[1]][[j]]))
    index = match(num_other, prov_first$Aantal)
    prov <-  prov_first$Municipality[[index]]
    temp <- paste(temp, prov)
  }
  
  municipalities[i] <- paste(temp, sep = ", ")
  print(municipalities[i])
}

MapperNodes$Nodesize <- as.integer(vertex.mean)
MapperNodes$Nodename <- municipalities

MapperNodes

forceNetwork(Nodes = MapperNodes, Links = MapperLinks, 
            Source = "Linksource", Target = "Linktarget",
            Value = "Linkvalue", NodeID = "Nodegroup",
            Group = "Nodegroup", opacity = 1, opacityNoHover = 1,
            linkDistance = 75, charge = -15,
            Nodesize = "Nodesize")  



```